---
title: "qPCR Analysis"
output: html_document
---

# Load and convert rawdata from LC480

```{r loaddata, include=FALSE}

library(qpcR)
library(HTqPCR)
library(tibble)
library(readr)
library(dplyr)
library(openxlsx)
library(ggplot2)

## GENERAL

# Sample1 , Sample2, Sample3 and Sample4 are used as generic placeholders
# this needs to be renamed in interface to the actual sample name, and then replaced in the Dataset

# ##Inputs:
# sample list (will be calculated from XLSX file below)
samplelist <- list("1" = "Sample1", "2" = "Sample2", "3" = "Sample3")

# type of Cq calculation method
## must be one of: cpD2 (default), cpD1 or Cy0
cq_calc_method = "cpD2"

# was a robot used to pipet the plate?
robot <- TRUE

# input$maxCT <- 35
# input$minCT <- 5
maxCT <- 35
minCT <- 5


# input: qpcr_normalize_method
# Values:
#         deltaCt --> requires deltaCt.genes, a selection of genes (in featureNames) AND Ct.max -> maximum ct value expected
#         quantile
#         scale.rankinvariant
#         norm.rankinvariant
#         geometric.mean --> Ct.max -> maximum ct value expected
normalization <- "deltaCt"

# INPUT: refgenes 
refgenes <- c("GAPDH","PGK1")

# Target gene used as calibrator
calibrator <- "GAPDH"

#qPCR rawdata
#file <- "/Users/janwinter/OneDrive/PhD/Followup/Results/qPCR/2017-03-20_TEST_Primers/data/JW_20170321_qPCR_TestPrimer.txt"
file <- "/Users/janwinter/OneDrive/PhD/Followup/Results/qPCR/2017-04-27_HEKTCF_RLUC-noRTAPC-KLHL22-B4GALT6/2017-04-27_JW_FOLLOWUP_HEK_RLUC-noRTAPC-KLHL22-B4GALT6.txt"

# XSLX overview file
#file_xlsx <- "/Users/janwinter/OneDrive/PhD/Followup/Results/qPCR/2017-03-20_TEST_Primers/2017-03-20_qPCR_TEST_cDNASynthesis.xlsx"
file_xlsx <- "/Users/janwinter/OneDrive/PhD/Followup/Results/qPCR/2017-04-27_HEKTCF_RLUC-noRTAPC-KLHL22-B4GALT6/qPCR_Overview_MASTER.xlsx"

# read file data 
## use roche lightcycler defaults
file.read <- readr::read_tsv(file = file, col_names = c("SamplePos","SampleName","Prog","Seg","Cycle","Time","Temp","483-533"), skip = 2)
# make A1 to A01 to be consistent
#pattern <- expression("^(\\w{1})(\\d{1})$")
#file.read$SamplePos <- sub(pattern = pattern, replacement = paste("\\1","0","\\2", sep=""), x=  file.read$SamplePos, fixed = FALSE )

# convert to qpcR format flat file
## each row -> CYCLE
## each column -> Well
df.pcr <- NULL
## make new tibble with maximum number of cycles
df.pcr <- tibble::tibble("Cycles" = seq(from = min(file.read[,"Cycle"]), to = max(file.read[,"Cycle"]), by =1))

## Add names (unique ones of course) as columns, so we first make data frame for each Well that contains cycles 1-x and the 483-533 value
wells <- NULL

wells <- as.list(unique(file.read$SamplePos))
names(wells) <- unique(file.read$SamplePos)

#dplyr::filter(file.read, SamplePos == "A1" & Prog == 2)  %>% dplyr::select(2,3, 5, 8)

df.data <- lapply(wells, function(x){
  # get subset
  subset <- dplyr::filter(file.read, SamplePos == as.character(x) & Prog == 2)  %>% dplyr::select( 5, 8)
  # Get column 483-533
  #subset <- dplyr::select(subset, 5, 8)
  colnames(subset) <- c("Cycles",as.character(x))
  # Add to tibble
  df.pcr <<- dplyr::left_join(df.pcr, subset, by = "Cycles")
  return(subset)
  
})

df.data <- NULL
# df.pcr will store all information in a flat-file way for qPCR anakysis
# rows -> cycles
# columns <- wells
ncol(df.pcr)



## get melting curve information (Prog == 3 in data)
df.melting <- tibble::tibble("Temp" = unique(file.read[file.read$Prog == 3, "Temp"]$Temp))
#t <- dplyr::filter(file.read, SamplePos == "A1" & Prog == 3)  %>% dplyr::select( 7, 8)
#df.melting <<- dplyr::left_join(df.melting, t, by = "Temp")
temperature <- df.melting$Temp

df.data <- lapply(wells, function(x){
  # get subset
  subset <- dplyr::filter(file.read, SamplePos == as.character(x) & Prog == 3)  %>% dplyr::select( 7, 8)
  # Get column 483-533
  #subset <- dplyr::select(subset, 5, 8)
  colnames(subset) <- c("Temp", as.character(x))
  # Add to tibble
  df.melting <<- dplyr::left_join(df.melting, subset, by = "Temp", copy =TRUE)

  
})


## AVAILABLE DATA STRUCTURES
# file.read -> qPCR raw data
# df.pcr -> flat-file qPCR rawdata in qpcR format
# df.melting -> flat-file qPCR melting curve data (temp vs fluorescence)

# load annotation data
if(robot)
{
  xlsx_mastermix <- openxlsx::read.xlsx(file_xlsx, sheet = "Mastermix")
  xlsx_primer <- openxlsx::read.xlsx(file_xlsx, sheet = "cDNA")
  xlsx_overview <- as.data.frame(openxlsx::read.xlsx(file_xlsx, sheet = "qPCR Overview", colNames = TRUE, rowNames = TRUE), stringsAsFactors = FALSE)
} else {
  xlsx_overview <- as.data.frame(openxlsx::read.xlsx(file_xlsx, sheet = "qPCR Overview", colNames = TRUE, rowNames = TRUE), stringsAsFactors = FALSE)
}

# get Overview plate first

overview_plate <- list()
overview_plate$overview <- reshape2::melt(as.matrix(xlsx_overview))
pattern <- expression("^(\\d{1})$")
#overview_plate$overview$Var2 <- sub(pattern = pattern, replacement = paste("0","\\1", sep=""), x=  overview_plate$overview$Var2, fixed = FALSE )
overview_plate$overview$position <- paste0(overview_plate$overview$Var1, overview_plate$overview$Var2)

platemap <- dplyr::mutate(as.data.frame(overview_plate$overview),
                   Row=as.numeric(match(toupper(substr(position, 1, 1)), LETTERS)),
                   Column=as.numeric(substr(position, 2, 5)))

# Replace Sample with user names
# Replace Sample by stoff from List that user gives
  
  samplelist <- list()
  if(!robot)
  {
    samplelist <- as.list(unique(overview_plate$overview$value))
    names(samplelist) <- unique(overview_plate$overview$value)
  } else {
    samplelist <- as.list(unique(xlsx_mastermix$Sample))
    names(samplelist) <- unique(xlsx_mastermix$Sample)
    
    # name will stay old, but character will be the new name
  
    for(i in 1:length(samplelist))
   {
      xlsx_mastermix$Sample <- sub(pattern = names(samplelist)[i],replacement = samplelist[[i]],x = xlsx_mastermix$Sample)
      xlsx_primer$Sample <- sub(pattern = names(samplelist)[i],replacement = samplelist[[i]],x = xlsx_primer$Sample)
    }
  }

  


## make ggplot2 image ov overview plate
  plot_platemap_overview <- function(data=NA){
   g <- ggplot2::ggplot(data=data, aes(x=Column, y=Row)) +
    geom_point(data=expand.grid(seq(1, 24), seq(1, 16)), aes(x=Var1, y=Var2),
               color="grey90", fill="white", shape=21, size=6) +
    geom_point(aes(color=value), size=6) +
    coord_fixed(ratio=(26/24)/(18/16), xlim=c(0.5, 25), ylim=c(0.5, 17)) +
    scale_y_reverse(breaks=seq(1, 16), labels=LETTERS[1:16]) +
    scale_x_continuous(breaks=seq(1, 24)) +
  scale_shape_manual(values=seq(from=0, to = length(unique(platemap$value)), by=1 ) ) +
    labs(title="Overview plate") 
   
   print(g)
  }




  
  ### Get info from cDNA and Mastermix plate for Overview the robot is pipetting -> this is what will be used for identification of:
  # - Samples (Sample 1-4)
  # - associated target genes
  # - reference gene location
  
  
 
  platemapMastermix <- NA
  platemapPrimer <- NA
  
  if(robot)
  {
     # load MASTERMIX sheet, which contains the Sample information and the layout where which sample is
  # Sample = Sample Name
  # Rack.Position = where to pipet from
  # q_PCR_Well_Pos = where to pipet to (final plate)
  #
    platemapMastermix <- as.data.frame(xlsx_mastermix)
    platemapMastermix <- dplyr::mutate(platemapMastermix,
                   Row=as.numeric(match(toupper(substr(q_PCR_Well_Pos, 1, 1)), LETTERS)),
                   Column=as.numeric(substr(q_PCR_Well_Pos, 2, 5)))
    
      # Primer Plate - tells us which target genes
  # Type = Target gene
  # Rack.Position = from where it takes the primer set
  # q_PCR_Plate = to where it pipettes (final plate)
  # Sample = Sample1 to Sample 4 -> same as in MasterMix Plate
  # Replicate = Which technical Replicate
  platemapPrimer <- dplyr::mutate(xlsx_primer,
                   Row=as.numeric(match(toupper(substr(q_PCR_Well_Pos, 1, 1)), LETTERS)),
                   Column=as.numeric(substr(q_PCR_Well_Pos, 2, 5)))
    
  }
  
  
  # Occupiedl well by Samples
  plot_occupied <- function(data = NULL,title="", save=FALSE){
    if(!is.na(data))
    {
       g <- ggplot(data=data, aes(x=Column, y=Row)) +
    geom_point(data=expand.grid(seq(1, 24), seq(1, 16)), aes(x=Var1, y=Var2),
               color="grey90", fill="white", shape=21, size=6) +
    geom_point(size=10) +
    coord_fixed(ratio=(13/12)/(9/8), xlim=c(0.5, 24.5), ylim=c(0.5, 16.5)) +
    scale_y_reverse(breaks=seq(1, 16), labels=LETTERS[1:16]) +
    scale_x_continuous(breaks=seq(1, 24)) +
    labs(title=title)
      
      return(g)
    } else {
      return(NULL)
    }
     
  }
  
  plot_target_overview <- function(data=NULL, title="Plate Layout: Target Genes", save=FALSE, samples=FALSE)
  {
    if(!is.na(data))
    {
      g <- ggplot(data=data, aes(x=Column, y=Row)) +
      geom_point(data=expand.grid(seq(1, 24), seq(1, 16)), aes(x=Var1, y=Var2),
                 color="grey90", fill="white", shape=21, size=6) 
      if(samples)
      {
        g <- g +  geom_point(aes(colour=Sample), size=6) 
      } else {
        g <- g + geom_point(aes(colour=Type), size=6) 
      }
      
      g <- g + coord_fixed(ratio=(13/12)/(9/8), xlim=c(0.5, 24.5), ylim=c(0.5, 16.5)) +
      scale_y_reverse(breaks=seq(1, 16), labels=LETTERS[1:16]) +
      scale_x_continuous(breaks=seq(1, 24)) +
      labs(title=title)
      return(g)
    } else {return(NULL)}
    
  }

  
  plot_occupied(data=platemapMastermix,title="Mastermix was added to the following wells", save=FALSE)
  
  # PLot Samples
  plot_target_overview(data = platemapMastermix, title = "Plate Layout: Samples", save=FALSE, samples=TRUE)
  
  

  
  plot_occupied(data=platemapPrimer,title="Primers were added to the following wells", save=FALSE)

  
  
  ## Plot Target genes
  
  
  plot_target_overview(data = platemapPrimer, title = "Plate Layout: Target Genes", save=FALSE)

  
  
  
  
  ## Plate qPCR RAW cq Value
  ### DONE LATER
  
  
  # Make df.pcr a nice df with the following stuff:
  # column names -> SAMPLE-TARGET_X with X being the replicate and SAMPLE being the Sample name as defined, TARGET being the target genes
  # SAMPLE comes from MASTERMIX, X and TARGET from primer
  ## STRUCTURE:
  # SAMPLE-GENE_REPLICATE
  df_samples <- NULL
  # make new DF
  if(robot)
  {
    df_samples <- tibble("Position" = xlsx_primer$q_PCR_Well_Pos,
         "Type" = xlsx_primer$Type,
         "Replicate" = xlsx_primer$Replicate
         )
    
  # add Sample information from xlsx_mastermix
  df_samples <- dplyr::left_join(x=df_samples, y = xlsx_mastermix, by=c("Position" = "q_PCR_Well_Pos"))
  
  df_samples$SampleFinal <-  apply(df_samples,1, function(x) {
      sample <- x[["Sample"]]
      replicate = x[["Replicate"]]
      gene = x[["Type"]]
      return(paste(sample,"-", gene, sep=""))
    })
    
  } else {
    df_samples <- tibble("Position" = overview_plate$overview$position,
         "Type" = overview_plate$overview$value,
         "Replicate" = overview_plate$overview$position
         )
    
    df_samples$SampleFinal <-  apply(df_samples,1, function(x) {
      sample <- sub(x = x[["Type"]], pattern = "(.*)_(.*)", replacement = "\\1")
      replicate = x[["Replicate"]]
      gene = sub(x = x[["Type"]], pattern = "(.*)_(.*)", replacement = "\\2")
      return(paste(sample,"-", gene, sep=""))
    })
    
  }
    
  
  # make df.pcr to have included information of samples
  #test <- df.pcr
  colnames(df.pcr) <- sub(pattern = "(\\w{1}\\d{1,2}).*", replacement = "\\1" , x = colnames(df.pcr) )
  
  #colnames_df.pcr <- colnames(df.pcr)
  # colnames(df.pcr) <- sapply(colnames(df.pcr), function(x) {
  #   sample <- dplyr::filter(df_samples, Position == x)$SampleFinal
  #   if(length(sample ==1))
  #   {
  #     return(sample)
  #   } else {
  #     return(x)
  #   }
  # })
  # 
  ncol(df.pcr)
  
 
str(df.pcr)

```


# Now calculate the Cq values according to the selectes function

```{r calculate_CQ, include=FALSE}
ncol(df.pcr)

calc <- as.list(colnames(df.pcr[,2:ncol(df.pcr)]))
names(calc) <- colnames(df.pcr[,2:ncol(df.pcr)])
#length(colnames(df.pcr))
length(calc)

for(i in 1:length(calc))
{
  x <- names(calc)[i]
  out <- list()
  fitted <- try(qpcR::pcrfit(data = as.data.frame(df.pcr), 1, grep(pattern = paste("^",as.character(x),"$" , sep=""),x = colnames(df.pcr) ), model = l4 ))
  
  if(class(fitted) == "try-error")
      {
        out$fitted <- NA
        out$efficiency <- NA
        out$cq <- NA
      } else {
    # fitting worked
        out$fitted <- fitted
        efficiency = try(qpcR::efficiency(out$fitted, plot=FALSE, type="cpD2"))
        #efficiencyLRE = try(qpcR::LRE(out$fitted, plot=FALSE))
        if(class(efficiency) == "try-error" || length(efficiency$eff) > 1 || is.na(efficiency$eff) ) #|| length(efficiency$eff) > 1 || is.na(efficiency$eff)
        {
          # check if there is only 1 efficiency value (should be) and if it is not NA, otherwise set all to NA
          out$efficiency <- NA
          out$cq <- NA
        } else {

          out$efficiency <- efficiency
           # Fourth: get calculated Cq or calculate Cq for Cy0
      if(cq_calc_method == "Cy0")
      {
        cq <- try(qpcR::Cy0(object = out$fitted, plot = FALSE))
        if(class(cq) == "try-error")
        {
          cq <- NA
        } else {
          out$cq <- cq
        }
      } else
      {
        out$cq <- out$efficiency[[cq_calc_method]]
      }
      }

      }
  # return
  calc[[i]] <- out
}
  
  
plot(calc$D10$fitted)
calc$D10$fitted
calc$D10$efficiency

qpcR::efficiency(calc[[c("D10")]]$fitted, plot=TRUE, type = "Cy0")

#calc
```

```{r OLDcalculation}

 # Calculation is done FOR ALL SAMPLES taking into account the replicate information!
  # we will make a list of samples
  ## TARGET Gene
  ##  # Sample (Type) <- for each gene a list
  ##  ## fitted <- will carry the fitting
  ##  ## cq <- will carry the calculated cq value (user selectable)
  ##  ## any additional element will be within the list either as separate list or DF or whatever
  # samples <- list()
  # samples <- as.list(unique(df_samples$Sample))
  # names(samples) <- unique(df_samples$Sample)
  # for (i in 1:length(samples))
  # {
  #   samples[[i]] <- unique(as.list(dplyr::filter(df_samples, Sample == names(samples)[i])$Type))
  #   names(samples[[i]]) <- unique(as.list(dplyr::filter(df_samples, Sample == names(samples)[i])$Type))
  # }
  
  # target <- list()
  # target <- as.list(unique(df_samples$Type))
  # names(target) <- unique(df_samples$Type)
  # for (i in 1:length(target))
  # {
  #   target[[i]] <- unique(as.list(dplyr::filter(df_samples, Type == names(target)[i])$Sample))
  #   names(target[[i]]) <- unique(as.list(dplyr::filter(df_samples, Type == names(target)[i])$Sample))
  # }
  
  # make factorizing for target/sample combination
  #vals <- colnames(df.pcr)[2:length(colnames(df.pcr))]
  #vals2 <- sub(pattern = "(.+)_", replacement = "\\1",x = vals)
  # SampleCombination is xxxx-xxxx_ and replicate is _y
  
  # # MODLIST usage first
  # qpcr_all_analysis <- qpcR::modlist(x = df.pcr, model=l4, check = NULL, remove="none", labels = colnames(vals))
  # qpcr_analysis <-  qpcR::replist(qpcr_all_analysis, group = gl(length(qpcr_all_analysis)/3, 3), check = "uni2", remove="KOD", names = "first")
  # 
  

  # Run analysis based on
  ## TARGET
  # get columns for each target
 
  # #length_reps <- seq.int(from = 1, to = length(df_samples$Type), by=1)
  # for(i in 1:length(target))
  # {
  #   print(target[i])
  #   # now go for each sample
  #   for(u in 1:length(target[[i]]))
  #   {
  #     
  #     print(target[[i]][u])
  #     # pattern for this particular combination, find where the combination is in the 384 well plate
  #     pattern <- paste(names(target[[i]])[u],"-", names(target)[i], ".*", sep="")
  #     # First: Perform a fit for EACH SAMPLE (replicate)
  #     target[[i]][[u]] <- list()
  #     fitted <- try(qpcR::pcrfit(data = as.data.frame(df.pcr), 1, grep(pattern = pattern,x = colnames(df.pcr) ), model = l4 ))
  #     if(class(fitted) == "try-error")
  #     {
  #       target[[i]][[u]]$fitted <- NA
  #       target[[i]][[u]]$efficiency <- NA
  #       target[[i]][[u]]$cq <- NA
  #     } else {
  #       
  #       target[[i]][[u]]$fitted <- fitted
  #       efficiency = try(qpcR::efficiency(target[[i]][[u]]$fitted, plot=FALSE, type = cq_calc_method))
  #       if(class(efficiency) == "try-error")
  #       {
  #         target[[i]][[u]]$efficiency <- NA
  #         target[[i]][[u]]$cq <- NA
  #       } else {
  #         
  #         target[[i]][[u]]$efficiency <- efficiency
  #       
  #          # Fourth: get calculated Cq or calculate Cq for Cy0
  #     if(cq_calc_method == "Cy0")
  #     {
  #       cq <- try(qpcR::Cy0(object = target[[i]][[u]]$fitted, plot = FALSE))
  #       if(class(cq) == "try-error")
  #       {
  #         cq <- NA
  #       } else {
  #         target[[i]][[u]]$cq <- cq
  #       }
  #     } else 
  #     {
  #       target[[i]][[u]]$cq <- target[[i]][[u]]$efficiency[[cq_calc_method]]
  #     }
  #     }
  #         
  #     }
  #       
  #    
  #     # Second: Plot Fits
  #     #plot(target[[i]][[u]]$fitted)
  #     #plot(target[[i]][u]$fitted)
  #     # Third: Plot PCR Efficiency
  #    
  #     
  #     
  #   }
  # }

  
  # write this back in a DF for HTQPCR for further analysis
  
#str(target)
#plot(target[[i]][[u]]$fitted)
#str(target[[i]][[u]]$efficiency)
#str(target[[i]][[u]]$cq)

```



```{r MeltingCurve}

# Melting Curves
str(df.melting)
for(i in 2:ncol(df.melting))
{
  if(i == 2)
  {
    df.melting2 <- dplyr::select(df.melting, Temp, i)
    colnames(df.melting2) <- c(paste("Temp",i, sep="_"), colnames(df.melting)[i])
  } else {
    df.binding <- dplyr::select(df.melting, Temp, i)
    colnames(df.binding) <- c(paste("Temp",i, sep="_"), colnames(df.melting)[i])
    df.melting2 <- dplyr::bind_cols(df.melting2, df.binding) 
    df.binding <- NULL
  }
}


meltcurve <- qpcR::meltcurve(data = as.data.frame(df.melting2), temps = c(1,3), fluos = c(2,4), plot = TRUE)


# Raw fluorescence curves


```


# Put things into HTqPCR data structure

```{r htqpcr1, include=FALSE}
# write calc list wiht all cq values to a tibble for htqpcr
cq <- lapply(calc,function(x){
  return(x[["cq"]])
})
cq_df <- as.data.frame(t(as.data.frame(cq)))
cq_df$V1 <- as.numeric(cq_df$V1)

# FLAG Cq falues as NA for weird values
# Input: maxCT and minCT for maximum and minum threshold. Everything above/below is set to NA and will be marked as FLAGGED

# input$maxCT <- 35
# input$minCT <- 5
maxCT <- 35
minCT <- 5

cq_df$V1[cq_df$V1 >=maxCT] <- NA
cq_df$V1[cq_df$V1 <=minCT] <- NA

# Flag
cq_df$Flag[is.na(cq_df$V1)] <- "undetermined"
cq_df$Flag[!is.na(cq_df$V1)] <- "Passed"

cq_df$Position <- rownames(cq_df)
cq_df <- tibble::as_tibble(cq_df)
colnames(cq_df) <- c("Cq", "Flag", "Position")

df_samples <- dplyr::left_join(x=df_samples, y=cq_df, by="Position")

df_samples$Control <- df_samples$Type
df_samples$Control[df_samples$Control != calibrator] <- "Target"
df_samples$Control[df_samples$Control == calibrator] <- "Endogenous Control"



#View(df_samples)
#str(df_samples)
# path <- system.file("exData", package = "HTqPCR")
# head(read.delim(file.path(path, "files.txt")))
# 
# files <- read.delim(file.path(path, "files.txt"))
# readr::read_tsv(file.path(path, files$File[1]),col_names = FALSE)
# raw <- readCtData(files = files$File, path = path)

# raw

output_cqdata <- df_samples[, c("Position", "Type", "Sample", "Cq", "Control", "Flag")]



n_samples <- unique(output_cqdata$Sample)
n_samples <- n_samples[!is.na(n_samples)]
n_samples <- tibble::tibble("Files" = n_samples, "Treatment" = n_samples)

n_features <- nrow(dplyr::filter(df_samples, Sample == n_samples$Files[1]) %>% dplyr::select( Position))
# 
for(i in 1:length(n_samples$Files))
{
  
  fullplate_df <- NULL
  pos1 <- dplyr::filter(df_samples, Sample == n_samples$Treatment[i]) %>% dplyr::select( Position)
  fullplate_df <- tibble("Position" = pos1$Position)
  fullplate_df <- dplyr::left_join(fullplate_df, dplyr::filter(output_cqdata, Sample == n_samples$Treatment[i]))
  #fullplate_df <- dplyr::filter(output_cqdata, Sample == n_samples[i]) %>% dplyr::arrange(Type)
  pos <- dplyr::filter(df_samples, Sample == n_samples$Treatment[1]) %>% dplyr::select( Position)
  fullplate_df$Position <- pos$Position
  # fullplate_df <- dplyr::full_join(fullplate_df, dplyr::select(df_samples, Position), by= "Position")
  fullplate_df <- dplyr::arrange(fullplate_df,Type)
  #readr::write_tsv(x = dplyr::filter(output_cqdata, Sample == n_samples[i]), path = file.path(getwd(), n_samples[i]), col_names = FALSE)
  readr::write_tsv(x = fullplate_df, path = file.path(getwd(), n_samples$Treatment[i]), col_names = FALSE)
}

# config$userDir
#readr::write_tsv(x = output_cqdata, path = file.path(getwd(), n_samples[1]), col_names = FALSE)

# read back in for htqpcr as qcprdataset
qPCRraw <- HTqPCR::readCtData(files = n_samples$Files, path=getwd(), column.info = list("position" = 1,"feature" = 2,"Ct" = 4, "type"=5), n.features = n_features)
# 

## FLAG and FILTER
qPCRraw <- setCategory(qPCRraw, Ct.max = maxCT, Ct.min = minCT, groups=NULL, replicates = FALSE, flag = TRUE, flag.out = "Failed", verbose = TRUE)

# Show which samples are FLAGGED


pData(qPCRraw)


#readr::write_tsv(x = output_cqdata, path = file.path(getwd(), "test"), col_names = FALSE)

#qPCRraw <- HTqPCR::readCtData(files = "test", path=getwd(), column.info = list("position" = 1,"feature" = 2, "Ct" = 4, "type" = 5), n.features = nrow(df_samples))

#plotCtCard(qPCRraw, col.range = c(10, 35), well.size = 2)

#sample3.order <- rep(c(n_samples), each = length(unique(df_samples$Type)))
#qPCRnew2 <- changeCtLayout(sr.norm, sample.order = sample3.order)

#plotCtOverview(qPCRraw, genes = unique(df_samples$Type), groups = sampleNames(qPCRraw) , conf.int = TRUE)

#plotCtReps(qPCRraw,card=1, percent=1)

plotCtVariation(qPCRraw, variation = "sd", log = TRUE, main = "SD of replicated features", col = "lightgrey")
plotCtVariation(qPCRraw, variation = "sd", log = TRUE, col = "lightgrey", type = "detail", add.featurenames = TRUE, pch = " ", cex = 1.2)
plotCVBoxes(qPCRraw,stratify = "type")


# if featureClass or featureType is set
featureClass(qPCRraw)
featureCategory(qPCRraw)
featurePos(qPCRraw)
#raw.cat <- qPCRraw
#plotCtCategory(raw.cat)
#plotCtCategory(raw.cat, stratify = "class")

#plotCtCategory(raw.cat, by.feature = TRUE, cexRow = 0.1)

## make own qPCR data set

# Making pesudo-data, just to illustrate the example



#### NORMALIZE DATA



# Normalization can be done by multiple ways

# input: qpcr_normalize_method
# Values:
#         deltaCt --> requires deltaCt.genes, a selection of genes (in featureNames) AND Ct.max -> maximum ct value expected
#         quantile
#         scale.rankinvariant
#         norm.rankinvariant
#         geometric.mean --> Ct.max -> maximum ct value expected
# INPUT: refgenes 
refgenes <- c("PGK1")
qPCRraw <- try(HTqPCR::filterCategory(qPCRraw))

# check for NAs and replace them bei MEAN of rest replicates if possible
df <- getCt(qPCRraw)
genes <- attributes(df)$dimnames[[1]]
df <- as.tibble(getCt(qPCRraw))
df$targets <- genes
means <- aggregate(x = df,by = list(df$targets),FUN = function(x) { mean(x, na.rm=TRUE)})
# now we walk through tibble and check for NAs of same gene
cols <- colnames(df)
for(i in 1:(length(cols)-1) )
  {
   d <- dplyr::select_(df, cols[i], "targets" )
   
   df[cols[i]][1] <- apply(d, 1, function(x, colname = cols[i], target= "targets"){
     
     if(is.na(x[colname]))
     {
       replace <- means[means$Group.1 == x[target], colname]
     } else {
       replace <- x[colname]
     }
     return(as.numeric(replace))
     
   })
   
}
df$targets <- NULL
setCt(qPCRraw) <- as.matrix(df)

qPCRnorm <- normalizeCtData(qPCRraw, norm = "deltaCt", Ct.max = maxCT, deltaCt.genes = refgenes)

# After normalization, we laso put data into the tidy data frame

#tidy_qpcr <- tibble::as_tibble(fData(qPCRnorm))
tidy_qpcr <- NULL

# norm in object qPCRnorm, raw in qPCRraw

for(i in 1:length(sampleNames(qPCRnorm)))
{
  if(i==1)
  {
    # tidy Ct
    ct <- NULL
    ct <- tibble::as_tibble(getCt(qPCRraw)[,i])
    ct$value[ct$value >= maxCT] <- NA
    ct$value[ct$value <= minCT] <- NA
    tidy_qpcr <- tibble::as_tibble(fData(qPCRnorm)) %>% dplyr::bind_cols(tibble::as_tibble(rep(sampleNames(qPCRnorm)[i], times = nrow(fData(qPCRnorm))))) %>% dplyr::bind_cols(tibble::as_tibble(getCt(qPCRnorm)[,i])) %>% dplyr::bind_cols(ct) %>% dplyr::bind_cols(featureCategory(qPCRnorm)[i])
    colnames(tidy_qpcr) <- c("Gene", "Type", "Pos", "Sample" , "Cqnorm", "Cqraw", "Flagged")
    
    
  } else
  {
    # tidy Ct
    ct <- NULL
    tidy_qpcr_temp <- NULL
    ct <- tibble::as_tibble(getCt(qPCRraw)[,i])
    ct$value[ct$value >= maxCT] <- NA
    ct$value[ct$value <= minCT] <- NA
    
    tidy_qpcr_temp <- tibble::as_tibble(fData(qPCRnorm)) %>% dplyr::bind_cols(tibble::as_tibble(rep(sampleNames(qPCRnorm)[i], times = nrow(fData(qPCRnorm))))) %>% dplyr::bind_cols(tibble::as_tibble(getCt(qPCRnorm)[,i])) %>% dplyr::bind_cols(ct) %>% dplyr::bind_cols(featureCategory(qPCRnorm)[i])
    
    colnames(tidy_qpcr_temp) <- c("Gene", "Type", "Pos", "Sample" , "Cqnorm", "Cqraw", "Flagged")
    
    
    
    tidy_qpcr <- dplyr::bind_rows(tidy_qpcr, tidy_qpcr_temp)
    
  }
}

## add SD
## add SD for each target gene and sample

tidy_qpcr$SD <- apply(tidy_qpcr,1, function(x){
  
      df_sd <- dplyr::filter(tidy_qpcr, Gene == x["Gene"], Sample == x["Sample"]) %>% dplyr::select(Gene, Cqraw)
      df_sd$SD <- sd(df_sd$Cqraw, na.rm = TRUE)
      df_sd$Cqraw <- NULL
      
      # bind to tmp
      #tidy_qpcr_temp <- dplyr::left_join(tidy_qpcr_temp,unique(df_sd),by = "Gene")
      return(unique(df_sd$SD))
})



View(tidy_qpcr)

getCt(qPCRraw)
getCt(qPCRnorm)
plot(exprs(qPCRraw), exprs(qPCRnorm), pch = 20, main = paste("dCT normalization using", paste(refgenes, collapse = ", ") , sep= " "), col = rep(brewer.pal(6, "Spectral"), each = 96))


plotCtCor(qPCRraw, main = "Ct correlation")
plotCtCor(qPCRnorm, main = "Ct correlation")
plotCtDensity(qPCRraw)
plotCtDensity(qPCRnorm)


plotCtOverview(qPCRnorm, genes = unique(df_samples$Type), groups = sampleNames(qPCRraw) , conf.int = TRUE)

# Plot BOXES that the CT distribution compared to endogenous control
plotCtBoxes(qPCRnorm,stratify = "type")

# Plot Scatter for similarness of samples
# user input: Samples, we will use the number in the slot, e.g. 1 and 2
plotCtScatter(qPCRnorm, cards = c(1, 3), col = "type", diag = TRUE)
plotCtPairs(qPCRnorm, col = "type", diag = TRUE)

# PCA
plotCtPCA(qPCRraw)
plotCtPCA(qPCRraw,features = FALSE)

plotCtPCA(qPCRnorm)
plotCtPCA(qPCRnorm,features = FALSE)

# PLot Heatmap
# Values:
#         main -> title of plot
#         dist -> euclidean or pearson (for caluclating distances)
#         gene.names -> character vector to replace row entries
#         sample.names -> character vecotr to replace column entries
plotCtHeatmap(qPCRraw, gene.names = featureNames(qPCRraw), dist = "euclidean")
plotCtHeatmap(qPCRnorm, gene.names = featureNames(qPCRnorm), dist = "euclidean")

plotCtHeatmap(qPCRraw, gene.names = featureNames(qPCRraw), dist = "pearson")
plotCtHeatmap(qPCRnorm, gene.names = featureNames(qPCRnorm), dist = "pearson")


clusterCt(qPCRraw, type = "samples")
clusterCt(qPCRraw, type = "genes")

clusterCt(qPCRnorm, type = "samples")
clusterCt(qPCRnorm, type = "genes")


## Plot ggplot2 different GENE according to SAMPLE using tidy_qpcr!
# "Gene"   "Type"   "Pos"    "Sample" "Cqnorm" "Cqraw" "SD"

# INPUT USER
# genes <- genes to plot
# NORM or RAW <- will use Cqraw or Cqnorm (no SD)
# sample <- by default: all, otherwise just the sample

## according to this we will perform a subsetting

# plot RAW
title <- "Raw Cq Values"
p <- ggplot(tidy_qpcr, aes(x=Gene, y=Cqraw, fill=Sample)) + 
    geom_bar(stat="identity", position = "dodge") +
    geom_errorbar(aes(ymin=Cqraw-SD, ymax=Cqraw+SD),
                  width=.2,                    # Width of the error bars
                  position=position_dodge(.9)) +
    #geom_jitter(shape=16, position=position_jitter(0.2)) +
    labs(title = title, x = "Genes", y = "Cq values") +
    ggplot2::theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(size = rel(1.1)), legend.position="bottom")
p

# Calculate statistical tests

# user input:
## groups <- which groups to compare
## calibrator <- which is the calibrator

# ddct --> ddCT
# FC --> the FOLD CHANGE calculated by ddCT

getCtHistory(qPCRnorm)

### ONLY MANN -WHITNEY SEEMS TO WORK

## T-Test
?ttestCtData

ttestCtData(qPCRnorm[,c(1,3)], groups = c(1,3), calibrator = 1, alternative = "two.sided", paired = FALSE, replicates = TRUE, sort = TRUE, stringent = TRUE, p.adjust = "BH")

## Mann-Whitney
?mannwhitneyCtData

mannwhitneyCtData(qPCRnorm[,c(1,3)], groups = c(1,3), calibrator = 1, alternative = "two.sided", paired = FALSE, replicates = TRUE, sort = TRUE, stringent = TRUE, p.adjust = "BH")




# ## Limma
# 
# ?limmaCtData
# 
# design <- model.matrix(~0+n_samples$Treatment)
# colnames(design) <- n_samples$Treatment
# 
# contrasts <- makeContrasts(Sample2-Sample1, levels=design)
# # The actual test
# diff.exp <- limmaCtData(qPCRnorm, design=design, contrasts=contrasts)
# 
# 
# 
# # Load example preprocessed data
# data(qPCRpros)
# samples <- read.delim(file.path(system.file("exData", package="HTqPCR"), "files.txt"))
# # Define design and contrasts
# design <- model.matrix(~0+samples$Treatment)
# colnames(design) <- c("Control", "LongStarve", "Starve")
# contrasts <- makeContrasts(LongStarve-Control, LongStarve-Starve, Starve-Control, levels=design)
# # The actual test
# diff.exp <- limmaCtData(qPCRpros, design=design, contrasts=contrasts)
# # Some of the results
# diff.exp[["LongStarve - Control"]][1:10,]
# 



plotCtRQ(qPCRraw)




```


```{r Plots}

########## PLATE QC and OVERVIEW

plot_platemap_overview(data=platemap)

## ONLY AVAILABLE IF ROBOT ==TRUE
## occupied wells acccording to mixing
plot_occupied(data=platemapMastermix,title="Mastermix was added to the following wells", save=FALSE)

plot_target_overview(data = platemapMastermix, title = "Plate Layout: Samples", save=FALSE, samples=TRUE)
  
plot_occupied(data=platemapPrimer,title="Primers were added to the following wells", save=FALSE)

## Plot Target genes according to robot
plot_target_overview(data = platemapPrimer, title = "Plate Layout: Target Genes", save=FALSE)



######### Individual wells

## for each unique sample including three replicates
## QC ONLY!!
## user can select a sample and  and plots ar created as QC using the well information FROM SAMPLEFINAL, e.g. combination of sample and target gene

userselect <- "Sample1-ADAM10"

pos <- dplyr::filter(df_samples, SampleFinal == userselect) %>% dplyr::select(Position)

# # plot RAW fluorescences
# plot_raw <- function(data=NA, pos=NULL)
# {
#   if(!is.na(data) && !is.null(pos))
#   {
#     for(i in 1:length(pos))
#     {
#       plot(data[[pos[i]]]$fitted)
#     }
#   } else { return(NULL)}
# }
# 
# plot_raw(calc, pos=pos$Position)

# Plot fitting and cq calculation
plot_cq_fitted <- function(data=NA, pos=NULL, cq=cq_calc_method)
{
  if(!is.na(data) && !is.null(pos) &&!is.na(cq_calc_method))
  {
    for(i in 1:length(pos))
    {
      qpcR::efficiency(data[[pos[i]]]$fitted, plot=TRUE, type = cq_calc_method)
    }
  } else { return(NULL)}
  
}

par(mfrow=c(2,2))
plot_cq_fitted(data=calc, pos=pos$Position, cq = cq_calc_method)



## Plate Overview CQ

platemap_cq2 <- dplyr::mutate(tidy_qpcr,
                   Row=as.numeric(match(toupper(substr(Pos, 1, 1)), LETTERS)),
                   Column=as.numeric(substr(Pos, 2, 5)) ) 

platemap_cq2$Var1 <- LETTERS[platemap_cq2$Row]
platemap_cq2$Var2 <- platemap_cq2$Column

platemap_cq2$Cqnorm[platemap_cq2$Flagged == "Undetermined"] <- NA



plot_cq_overview <- function(data=NA, norm = FALSE, sample=NULL){
  data <- as.data.frame(data)
  if(norm)
  {
    selectcol <- "Cqnorm"
  } else
  {
    selectcol <- "Cqraw"
  }
  
  if(is.null(sample))
  {
    sampleselect <- 1
  } else
  {
    sampleselect <- sample
  }
  sampleselect = "Sample1"
  data <- platemap_cq2
  data <- dplyr::filter(data, Sample == sampleselect)
  
  norm = FALSE
   g <- ggplot2::ggplot(data=data, aes(x=Column, y=Row)) +
    geom_point(data=expand.grid(seq(1, max(data$Column)), seq(1, max(data$Row))),aes(x=Var1, y=Var2),
               color="grey90", fill="white", shape=21, size=9) +
    geom_point(aes_string(color=selectcol), size=9) +
    scale_colour_gradient() +
     geom_text(aes_string(label = selectcol), size=2) +
    coord_fixed(ratio=((max(data$Column)+2)/max(data$Column))/((max(data$Row)+2)/max(data$Row)), xlim=c(0.5, (max(data$Column)+1) ), ylim=c(0.5, (max(data$Row)+1))) +
    scale_y_reverse(breaks=seq(1, max(data$Row)), labels=LETTERS[1:max(data$Row)]) +
    scale_x_continuous(breaks=seq(1, max(data$Column))) +
  #scale_shape_manual(values=seq(from=0, to = length(unique(data$value)), by=1 ) ) +
    labs(title="Overview plate") 
   
   print(g)
  }


## for each Sample give a overview of all gene
# cq values

userselect_sample <- "Sample1"

df_samples

cq_plot <- dplyr::filter(df_samples, Sample == userselect_sample) %>% dplyr::select(Cq,Type)





## for each target gene give an overview of all sample
# cq values





############## QC

# Normalization Plot
plot(exprs(qPCRraw), exprs(qPCRnorm), pch = 20, main = paste("ddCT normalization using", paste(refgenes, collapse = ", ") , sep= " "), col = rep(brewer.pal(6, "Spectral"), each = 96))


#plotCtCor(qPCRraw, main = "Cq correlation")
#plotCtCor(qPCRnorm, main = "Cq correlation")

# Cq variation and Overall quality
plotCtVariation(qPCRraw, variation = "sd", log = TRUE, main = "SD of replicated features", col = "lightgrey")
plotCtVariation(qPCRraw, variation = "sd", log = TRUE, col = "lightgrey", type = "detail", add.featurenames = TRUE, pch = " ", cex = 1.2)

plotCtCategory(q = qPCRnorm)
plotCtCategory(q = qPCRnorm, stratify = "type")


# Cq Density Plot
plotCtDensity(qPCRraw,xlab = "", ylab = "",main = "title")
plotCtDensity(qPCRnorm, xlab = "", ylab = "",main = "title")

plotCtHistogram(q = qPCRnorm)


# Cq Overview along all Samples
# will be done by ggplot!

#plotCtOverview(qPCRnorm, genes = unique(df_samples$Type), groups = sampleNames(qPCRraw) , conf.int = TRUE)

# Plot BOXES that the CT distribution compared to endogenous control
plotCtBoxes(qPCRraw, stratify = "type",main = "", ylab = "" )
plotCtBoxes(qPCRnorm, stratify = "type",main = "", ylab = "" )

# Plot Scatter for similarness of samples
# user input: Samples, we will use the number in the slot, e.g. 1 and 2
plotCtScatter(qPCRraw, col = "type", diag = TRUE, cor = TRUE,Ct.max = 35, main ="title")
plotCtPairs(qPCRraw, col = "type", diag = TRUE, cor = TRUE,Ct.max = 35, main ="title")
plotCtScatter(qPCRnorm, col = "type", diag = TRUE, cor = TRUE,Ct.max = 35, main ="title", xlab = "xlab", ylab = "ylab")
plotCtPairs(qPCRnorm, col = "type", diag = TRUE, cor = TRUE,Ct.max = 35, main ="title")



# PCA
plotCtPCA(qPCRraw,scale = FALSE)
plotCtPCA(qPCRraw,features = FALSE)

plotCtPCA(qPCRnorm)
plotCtPCA(qPCRnorm,features = FALSE)

# PLot Heatmap
# Values:
#         main -> title of plot
#         dist -> euclidean or pearson (for caluclating distances)
#         gene.names -> character vector to replace row entries
#         sample.names -> character vecotr to replace column entries
plotCtHeatmap(qPCRraw, gene.names = featureNames(qPCRraw), dist = "euclidean",main = "title")
plotCtHeatmap(qPCRnorm, gene.names = featureNames(qPCRnorm), dist = "euclidean",main = "title")

plotCtHeatmap(qPCRraw, gene.names = featureNames(qPCRraw), dist = "pearson",main = "title")
plotCtHeatmap(qPCRnorm, gene.names = featureNames(qPCRnorm), dist = "pearson",main = "title")


clusterCt(qPCRraw, type = "samples")
clusterCt(qPCRraw, type = "genes")

clusterCt(qPCRnorm, type = "samples")
clusterCt(qPCRnorm, type = "genes",dist = "euclidean")

```




```{r analysis}

###### TARGET genes are selected
####  always data for all samples cotnaining this gene are plotted
## INPUTS
# - target gene
# - calibrator (from sample)

## Outputs
# DATA TABLE  with all data and FC to download, new column CALIBRATOR which the sample name used for calibration
# PLOT        ggplot2 column chart grouped by either TARGET GENE or SAMPLE (if 1 target gene is selected)


# plot 1: raw Cq values form qpcr_tidy
tidy_qpcr
plot_qpcr_analysis_CQ(data = tidy_qpcr, target = "ADAM10", refgenes = "GAPDH")
plot_qpcr_analysis_CQ <- function(data = tidy_qpcr, target = NULL, yval = "Cqnorm", SD = "SD", refgenes = NULL)
{
  if(length(target) == 1)
  {
    xval <- "Sample"
    fillval <- "Gene"
  } else
  {
    xval <- "Gene"
    fillval <- "Sample" 
  }
  
  # get data
  data <- dplyr::filter(data, Gene %in% target)
  
  # set title and axes
  if(yval == "Cqraw")
  {
    title <- "Calculated Cq values"
    ylab <- "Cq"
  } else {
    title <- paste("dCq values normalized to ",paste(refgenes, collapse = ","), sep="")
    ylab <- "dCq"
  }
  
  # make plot
   p <- ggplot(data, aes_string(x=xval, y=yval,fill=fillval)) + 
    geom_bar(stat="identity", position = "dodge", na.rm = TRUE)
  
  if(yval == "Cqraw")
  {
    p <- p + geom_errorbar(aes(ymin=Cqraw-SD, ymax=Cqraw+SD),
                  size=.3,    # Thinner lines
                  width=.2,
                  position=position_dodge(.9)
                  ) 
  }
  if(yval == "Cqnorm")
  {
    p <- p + geom_errorbar(aes(ymin=Cqnorm-SD, ymax=Cqnorm+SD),
                  size=.3,    # Thinner lines
                  width=.2,
                  position=position_dodge(.9)
                  ) 
  }
    
   p <- p + ggplot2::theme_minimal() +
     labs(fill = fillval) +
    labs(title = title, y = ylab) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(size = rel(1.1)), legend.position="bottom")
  
  p
  
  #return(p)
}




## calculate Foldchange AND ddCq between samples

# select TARGET gene cqnorm
# select samples
# for each target gene divide Cq of samples by the one of the calibrator
# FIRST:  calculate dCQ with Cq_target-Cq_refgene (done by nornalization -> qPCRnorm)
# SECOND: calculate ddCq with Cq_normtarget1 - Cqnormtarget2 

samples <- c("Sample1", "Sample2")
genes <- c("DKK1","ADAM10")
calibrator <- "Sample1"

# create tibble FOR EACH TARGET GENE

df_analysis <- qpcr_get_analysis(tidydata = tidy_qpcr, samples = samples, genes = genes, calibrator = calibrator)

qpcr_get_analysis <- function(tidydata = NULL, samples = NULL, genes = NULL, calibrator = NULL){

  if(any(is.null(tidydata), is.null(samples), is.null(genes), is.null(calibrator)))
  {
    return()
  }
  
  for(i in 1:length(genes))
  {
    df_analysis <- NULL
    df_analysis <- dplyr::filter(tidydata, Sample %in% samples) %>% dplyr::filter(Gene %in% genes[i])

    division <- unique(dplyr::filter(tidydata, Sample %in% calibrator & Gene %in% genes[i]) %>% dplyr::select(Cqnorm))
    
    df_analysis$ddCq <- apply(df_analysis, 1, function(x, gene = genes[i]){
      df_tmp <- dplyr::filter(tidydata, Sample %in% x["Sample"] & Gene %in% gene)
      # print(df_tmp)
      df_tmp$FC <- df_tmp$Cqnorm - division$Cqnorm
      return(unique(df_tmp$FC))
      
    })
    
    df_analysis$FC <- apply(df_analysis, 1, function(x, gene = genes[i]){
      df_tmp <- dplyr::filter(tidydata, Sample %in% x["Sample"] & Gene %in% gene)
      df_tmp$FC <- 2^-(df_tmp$Cqnorm - division$Cqnorm)
      return(unique(df_tmp$FC))
      
    })
    
    df_analysis$FCsem <- apply(df_analysis, 1, function(x, gene = genes[i]){
      df_tmp <- dplyr::filter(tidydata, Sample %in% x["Sample"] & Gene %in% gene)
      df_tmp$FC <- df_tmp$Cqnorm / division$Cqnorm
      SD <- dplyr::filter(tidydata,  Sample %in% x["Sample"] & Gene %in% gene) %>% dplyr::select(SD)
      SD <- unique(SD$SD)
      
      if(!is.na(SD))
      {
        df_tmp$FCsem <- 1-(2^(-(SD) / sqrt(nrow(dplyr::filter(tidydata,  Sample %in% x["Sample"] & Gene %in% gene)))))
      } else {
        df_tmp$FCsem <- NA
      }
      return(unique(df_tmp$FCsem))
      
    })
    
    # add to df_analysis if necessary
    if(i!=1)
    {
      df_return <- dplyr::bind_rows(df_return, df_analysis)
    } else {
      df_return <- df_analysis
    }

  }
  
# return whole tidy dataframe
return(df_return)

}


## Plot 2: ddCq values
plot_qpcr_analysis_calibrated(data = df_analysis,  yval = "FC", samples = samples, calibrator = calibrator, refgenes = NULL)

plot_qpcr_analysis_calibrated <- function(data = NULL, yval = "FC", samples = NULL, calibrator = NULL, refgenes = NULL)
{
  
  ####
  # data must be tibble derived by qpcr_get_analysis
  ####
  
   if(any(is.null(data), is.null(samples), is.null(calibrator)))
  {
    return()
  }
  
  if(length(unique(data$Gene)) == 1)
  {
    xval <- "Sample"
    fillval <- "Gene"
  } else
  {
    xval <- "Gene"
    fillval <- "Sample" 
  }
  
  # DATA is already pre-defined by qpcr_get_analysis
  # set title and axes
  if(yval == "ddCq")
  {
    title <- paste("ddCq calibrated to ", calibrator, sep="")
    ylab <- "ddCq"
  } else {
    title <- paste("Foldchanges calibrated to ", calibrator, sep="")
    ylab <- "Foldchange"
  }
  
  # make plot
   p <- ggplot(data, aes_string(x=xval, y=yval,fill=fillval)) + 
    geom_bar(stat="identity", position = "dodge", na.rm = TRUE)
  
  if(yval == "FC")
  {
    p <- p + geom_errorbar(aes(ymin=FC-FCsem, ymax=FC+FCsem),
                  size=.3,    # Thinner lines
                  width=.2,
                  position=position_dodge(.9)
                  ) 
  } else if(yval == "ddCq")
  {
    p <- p + geom_errorbar(aes(ymin=ddCq-SD, ymax=ddCq+SD),
                  size=.3,    # Thinner lines
                  width=.2,
                  position=position_dodge(.9)
                  ) 
  }
    
   p <- p + ggplot2::theme_minimal() +
     labs(fill = fillval) +
    labs(title = title, y = ylab) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(size = rel(1.1)), legend.position="bottom")
  
  p
  
  #return(p)
}


```
